<!DOCTYPE html>
<html lang="en">
<%
  // Safely unwrap product data so template won't break if undefined
  const safeProduct = product || {};

  // Build a usable image path: allow absolute URLs, data URIs, or already-prefixed /images
  const resolveImage = (src) => {
    if (!src) return '';
    if (/^(https?:)?\/\//i.test(src) || src.startsWith('data:') || src.startsWith('/images/')) return src;
    return '/images/' + src;
  };

  // Collect unique images (image1 + image2)
  const imageList = [resolveImage(safeProduct.image1), resolveImage(safeProduct.image2)]
    .filter(Boolean)
    .filter((src, idx, arr) => arr.indexOf(src) === idx);

  // Numeric helpers with fallbacks for price and stock
  const priceValue = Number(safeProduct.price) || 0;
  const stockValue = Number.isFinite(Number(safeProduct.stock)) ? Number(safeProduct.stock) : null;
  const inStock = stockValue === null ? true : stockValue > 0;
  const statusValue = String(safeProduct.status || 'available').toLowerCase();
  const isAvailable = statusValue !== 'unavailable';
  const wishlistEntry = wishlistItem || null;
  const wishlistId = wishlistEntry ? wishlistEntry.wishlist_id : null;
  const isWishlisted = Boolean(wishlistId);
  const canPurchase = isAvailable && inStock;
  const qtyDisabled = !canPurchase;
  const wishlistDisabled = !isAvailable && !isWishlisted;

  // Prepare text for ingredients + description bullet list
  const ingredientText = (safeProduct.ingredient_list || '').trim();
  const descriptionItems = (safeProduct.description || '')
    .split('.')
    .map(item => item.trim())
    .filter(Boolean)
    .map(item => item.endsWith('.') ? item : item + '.');
%>
<head>
  <!-- Document metadata and styles -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= safeProduct.product_name || 'Product' %> | Repawblic Pets</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Manrope:wght@500;600;700&family=Source+Sans+3:wght@400;600&display=swap">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/product.css">
</head>
<body class="product-body">
  <%- include('partials/navbar') %>

  <!-- Page wrapper with data hooks for scripts -->
  <main
    class="product-page"
    data-product-id="<%= safeProduct.product_id %>"
    data-stock="<%= stockValue ?? '' %>"
    data-status="<%= statusValue %>"
    data-images='<%- JSON.stringify(imageList) %>'
    data-alt="<%= safeProduct.product_name || 'Product image' %>">
    <div id="page-alert" class="alert alert-success alert-dismissible fade show d-none page-alert" role="alert">
      <span class="page-alert__message"></span>
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>
    <div class="back-row">
      <a id="back-to-products" class="back-link" href="/shopping" aria-label="Back to products">
        &lt; Back to Products
      </a>
    </div>
    <section class="product-layout">
      <aside class="media-column">
        <div class="media-slider">
          <!-- Main image viewport with prev/next arrows and live region -->
          <div class="slider-main" tabindex="0" aria-label="Product image gallery">
            <button class="slider-arrow slider-arrow--prev" type="button" aria-label="Previous image">&#8249;</button>
            <img src="<%= imageList[0] %>" alt="<%= (safeProduct.product_name || 'Product image') + ' image 1' %>">
            <button class="slider-arrow slider-arrow--next" type="button" aria-label="Next image">&#8250;</button>
            <div class="slider-live" aria-live="polite" aria-atomic="true"></div>
          </div>
          <!-- Thumbnail strip for direct image selection -->
          <div class="slider-thumbs" aria-label="Product image thumbnails">
            <ul class="thumbs-list">
              <% imageList.forEach((src, idx) => { %>
                <li>
                  <button type="button" class="thumb-btn <%= idx === 0 ? 'is-active' : '' %>" data-index="<%= idx %>" aria-label="View image <%= idx + 1 %>">
                    <img src="<%= src %>" alt="Thumbnail <%= idx + 1 %> for <%= safeProduct.product_name || 'product' %>">
                  </button>
                </li>
              <% }) %>
            </ul>
          </div>
        </div>
      </aside>

      <section class="content-column">
        <!-- Product title, wishlist toggle, price, stock chip, quantity, and CTA buttons -->
        <article class="detail-card sticky-info">
          <div class="title-row">
            <div class="title-text">
              <!-- Category label and main product name -->
              <p class="product-kicker"><%= safeProduct.category || 'Featured product' %></p>
              <h1 class="product-title"><%= safeProduct.product_name || 'Product Name' %></h1>
            </div>
            <!-- Wishlist icon -->
            <button
              id="wishlist-btn"
              class="wishlist-icon <%= isWishlisted ? 'wishlist-icon--added' : '' %>"
              type="button"
              aria-label="<%= isWishlisted ? 'Remove from wishlist' : 'Add to wishlist' %>"
              aria-pressed="<%= isWishlisted ? 'true' : 'false' %>"
              data-wishlist-id="<%= wishlistId || '' %>"
              <%= wishlistDisabled ? 'disabled' : '' %>>
              <img src="/images/wishlist-logo.jpg" alt="">
            </button>
          </div>

          <!-- Price and stock status -->
          <div class="price-stock-row">
            <div class="price-block">
              <span class="price-value">$<%= priceValue.toFixed(2) %></span>
            </div>
            <span class="stock-chip <%= !isAvailable ? 'stock-chip--unavailable' : inStock ? '' : 'stock-chip--out' %>">
              <%= !isAvailable ? 'Unavailable' : inStock ? 'In stock' : 'Out of stock' %>
            </span>
          </div>

          <!-- Quantity selector -->
          <div class="quantity-row">
            <label for="quantity-input">Quantity</label>
            <div class="qty-control">
              <button type="button" class="qty-btn" data-step="-1" aria-label="Decrease quantity" <%= qtyDisabled ? 'disabled' : '' %>>-</button>
              <input id="quantity-input" name="quantity" type="number" min="1" value="1" <%= qtyDisabled ? 'disabled' : '' %> <%= stockValue !== null ? `max="${Math.max(stockValue, 1)}"` : '' %>>
              <button type="button" class="qty-btn" data-step="1" aria-label="Increase quantity" <%= qtyDisabled ? 'disabled' : '' %>>+</button>
            </div>
          </div>

          <!-- Add to Cart / Buy Now or disabled when out of stock -->
          <div class="actions-row">
            <% if (!isAvailable) { %>
              <button class="cta-btn cta-btn--out" type="button" disabled>Unavailable</button>
            <% } else if (inStock) { %>
              <button id="add-to-cart-btn" class="cta-btn cta-btn--cart" type="button">
                Add to Cart
              </button>
              <button id="buy-now-btn" class="cta-btn cta-btn--buy" type="button">
                Buy Now
              </button>
            <% } else { %>
              <button class="cta-btn cta-btn--out" type="button" disabled>Out of Stock</button>
            <% } %>
          </div>

          <!-- Live status text for cart/wishlist actions -->
          <div id="action-status" class="action-status" role="status" aria-live="polite"></div>
        </article>

        <!-- Product description list -->
        <article class="detail-card" id="description">
          <h2>Description</h2>
          <!-- Render bullet points if description exists -->
          <% if (descriptionItems.length) { %>
            <ul class="description-list">
              <% descriptionItems.forEach((item) => { %>
                <li><%= item %></li>
              <% }) %>
            </ul>
          <% } else { %>
            <!-- Fallback text when description is missing -->
            <p>A detailed description will appear here once added.</p>
          <% } %>
        </article>

        <!-- Ingredient section -->
        <article class="detail-card" id="ingredients">
          <h2>Ingredients</h2>
          <!-- Single ingredient line or placeholder -->
          <% if (ingredientText) { %>
            <div class="ingredient-list">
              <span class="ingredient-item"><%= ingredientText %></span>
            </div>
          <% } else { %>
            <p>No ingredients have been listed yet.</p>
          <% } %>
        </article>

        <!-- Reviews block -->
        <article class="detail-card" id="reviews">
          <h2>Reviews</h2>
          <% const safeReviews = Array.isArray(reviews) ? reviews : []; %>
          <% if (safeReviews.length) { %>
            <div class="reviews-list">
              <% safeReviews.forEach((r) => { %>
                <div class="review-item">
                  <div class="review-meta">
                    <strong><%= r.username || 'Customer' %></strong>
                    <span class="review-rating">â˜… <%= Number(r.rating || 0).toFixed(1) %></span>
                    <span class="review-date"><%= r.created_at ? new Date(r.created_at).toLocaleDateString('en-SG', { dateStyle: 'medium' }) : '' %></span>
                  </div>
                  <div class="review-text"><%= r.review_text || '' %></div>
                </div>
              <% }) %>
            </div>
          <% } else { %>
            <div class="reviews-placeholder">
              <div class="stars">&#9733;&#9733;&#9733;&#9733;&#9733;</div>
              <p>Reviews will show up here.</p>
            </div>
          <% } %>
        </article>
      </section>
    </section>
  </main>

  <!-- Client-side interactions: quantity controls, cart/wishlist, slider -->
  <script>
    (() => {
      // Grab main page element; stop if missing
      const page = document.querySelector('.product-page');
      if (!page) return;

      // Data for slider and labels
      const productImages = JSON.parse(page.dataset.images || '[]');
      const sliderAltText = page.dataset.alt || 'Product image';

      // Core elements reused by handlers
      const productId = page.dataset.productId;
      const stock = Number(page.dataset.stock);
      const isAvailable = page.dataset.status !== 'unavailable';
      const qtyInput = document.getElementById('quantity-input');
      const qtyButtons = Array.from(document.querySelectorAll('.qty-btn'));
      const addBtn = document.getElementById('add-to-cart-btn');
      const buyBtn = document.getElementById('buy-now-btn');
      const wishlistBtn = document.getElementById('wishlist-btn');
      const statusEl = document.getElementById('action-status');
      const backLink = document.getElementById('back-to-products');
      const pageAlert = document.getElementById('page-alert');
      const pageAlertMessage = pageAlert?.querySelector('.page-alert__message');
      const pageAlertParent = pageAlert?.parentElement;

      const safeSameOriginPath = (value) => {
        try {
          const target = new URL(value, window.location.origin);
          if (target.origin !== window.location.origin) return '';
          return target.pathname + target.search + target.hash;
        } catch (err) {
          return '';
        }
      };

      if (backLink) {
        const params = new URLSearchParams(window.location.search);
        const returnToParam = params.get('returnTo');
        const returnToPath = returnToParam ? safeSameOriginPath(returnToParam) : '';

        if (returnToPath) {
          backLink.href = returnToPath;
        } else {
          backLink.href = '/shopping';
          backLink.addEventListener('click', (event) => {
            const referrer = document.referrer || '';
            let sameOriginReferrer = false;

            if (referrer) {
              try {
                sameOriginReferrer = new URL(referrer).origin === window.location.origin;
              } catch (err) {
                sameOriginReferrer = false;
              }
            }

            if (sameOriginReferrer && window.history.length > 1) {
              event.preventDefault();
              window.history.back();
            }
          });
        }
      }

      // Update status text with optional tone modifier
      const setStatus = (msg, tone = 'neutral') => {
        if (!statusEl) return;
        statusEl.textContent = msg;
        statusEl.className = 'action-status ' + tone;
      };

      const showAlert = (message, tone = 'info') => {
        if (!pageAlert) return;
        if (!pageAlert.isConnected && pageAlertParent) {
          pageAlertParent.prepend(pageAlert);
        }
        if (pageAlertMessage) {
          pageAlertMessage.textContent = message;
        }
        pageAlert.className = `alert alert-${tone} alert-dismissible fade show page-alert`;
        pageAlert.classList.remove('d-none');
        pageAlert.scrollIntoView({ behavior: 'smooth', block: 'start' });
      };

      // Keep quantity within 1..stock (if stock is known)
      const clampQuantity = () => {
        let val = parseInt(qtyInput.value, 10);
        if (!Number.isFinite(val) || val < 1) val = 1;
        if (Number.isFinite(stock) && stock > 0) {
          val = Math.min(val, stock);
        }
        qtyInput.value = val;
        return val;
      };

      // Increment/decrement quantity buttons
      qtyButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const step = parseInt(btn.dataset.step, 10) || 0;
          qtyInput.value = (parseInt(qtyInput.value, 10) || 1) + step;
          clampQuantity();
        });
      });

      // Normalize quantity if user types a value
      qtyInput.addEventListener('change', clampQuantity);

      // Redirect to login when server says unauthorized
      const handleAuthFailure = (res) => {
        if (res.status === 401) {
          setStatus('Please log in to continue.', 'error');
          showAlert('Please log in to continue.', 'danger');
          window.location.href = '/login';
          return true;
        }
        return false;
      };

      // POST helper returning parsed JSON (or empty object)
      const postJSON = async (url, payload) => {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (handleAuthFailure(res)) throw new Error('login required');
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          const message = data.details || data.error || 'Request failed';
          throw new Error(message);
        }
        return res.json().catch(() => ({}));
      };

      // Enable/disable cart buttons together
      const setButtonsDisabled = (state) => {
        if (addBtn) addBtn.disabled = state;
        if (buyBtn) buyBtn.disabled = state;
      };

      // Add to cart handler; optionally redirect straight to checkout
      const handleCart = async ({ redirectToCheckout = false } = {}) => {
        if (!productId || !addBtn || !buyBtn) return;
        if (!isAvailable) {
          setStatus('This product is unavailable.', 'error');
          showAlert('This product is unavailable right now.', 'warning');
          return;
        }
        const quantity = clampQuantity();
        setButtonsDisabled(true);
        setStatus('Adding to cart...', 'neutral');

        try {
          const data = await postJSON('/cart', { product_id: productId, quantity });
          const action = data.action === 'updated' ? 'updated' : 'added';
          addBtn.classList.add('is-added');
          if (data.moved_from === 'wishlist') {
            setWishlistState(false, '');
            setStatus('Moved from wishlist to cart.', 'ok');
            showAlert('Moved from wishlist to cart.', 'success');
          } else if (action === 'updated') {
            setStatus('Cart quantity updated.', 'ok');
            showAlert('Item quantity updated in cart.', 'info');
          } else {
            setStatus('Added to cart.', 'ok');
            showAlert('Item added to cart successfully.', 'success');
          }
          if (redirectToCheckout) {
            window.location.href = '/checkout';
          }
        } catch (err) {
          console.error(err);
          const message = err?.message || 'An error occurred. Please try again.';
          setStatus(message, 'error');
          showAlert(message, 'danger');
        } finally {
          setButtonsDisabled(false);
        }
      };

      // Wishlist handler toggling icon state
      const setWishlistState = (isAdded, id) => {
        if (!wishlistBtn) return;
        wishlistBtn.classList.toggle('wishlist-icon--added', isAdded);
        wishlistBtn.setAttribute('aria-pressed', isAdded ? 'true' : 'false');
        wishlistBtn.setAttribute('aria-label', isAdded ? 'Remove from wishlist' : 'Add to wishlist');
        if (id) {
          wishlistBtn.dataset.wishlistId = id;
        } else {
          delete wishlistBtn.dataset.wishlistId;
        }
      };

      const handleWishlistAdd = async () => {
        if (!productId || !wishlistBtn) return;
        if (!isAvailable) {
          setStatus('This product is unavailable.', 'error');
          showAlert('This product is unavailable right now.', 'warning');
          return;
        }
        wishlistBtn.disabled = true;
        setStatus('Saving to wishlist...', 'neutral');

        try {
          const data = await postJSON('/wishlist', { product_id: productId });
          setWishlistState(true, data.wishlist_id);
          if (data.moved_from === 'cart') {
            if (addBtn) addBtn.classList.remove('is-added');
            setStatus('Moved from cart to wishlist.', 'ok');
            showAlert('Moved from cart to wishlist.', 'info');
          } else {
            setStatus('Added to wishlist.', 'ok');
            showAlert('Item added to wishlist.', 'info');
          }
        } catch (err) {
          console.error(err);
          const message = err?.message || 'An error occurred. Please try again.';
          setStatus(message, 'error');
          showAlert(message, 'danger');
        } finally {
          wishlistBtn.disabled = false;
        }
      };

      const handleWishlistRemove = async () => {
        const wishlistId = wishlistBtn?.dataset?.wishlistId;
        if (!wishlistId) return;
        wishlistBtn.disabled = true;
        setStatus('Removing from wishlist...', 'neutral');

        try {
          const res = await fetch(`/wishlist/${wishlistId}`, {
            method: 'DELETE',
            headers: { 'Accept': 'application/json' }
          });
          if (handleAuthFailure(res)) return;
          if (!res.ok) throw new Error('Request failed');
          setWishlistState(false, '');
          setStatus('Removed from wishlist.', 'ok');
          showAlert('Item removed from wishlist.', 'warning');
        } catch (err) {
          console.error(err);
          const message = err?.message || 'An error occurred. Please try again.';
          setStatus(message, 'error');
          showAlert(message, 'danger');
        } finally {
          wishlistBtn.disabled = false;
        }
      };

      // Hook cart buttons
      if (addBtn) {
        addBtn.addEventListener('click', () => handleCart({ redirectToCheckout: false }));
      }

      if (buyBtn) {
        buyBtn.addEventListener('click', () => handleCart({ redirectToCheckout: true }));
      }

      // Hook wishlist button
      if (wishlistBtn) {
        wishlistBtn.addEventListener('click', () => {
          if (wishlistBtn.classList.contains('wishlist-icon--added')) {
            handleWishlistRemove();
          } else {
            handleWishlistAdd();
          }
        });
      }

      // Image slider wiring: arrows, thumbnails, keyboard, swipe
      const initSlider = () => {
        const slider = document.querySelector('.media-slider');
        if (!slider || !productImages.length) return;

        const mainImg = slider.querySelector('.slider-main img');
        const liveRegion = slider.querySelector('.slider-live');
        const thumbList = slider.querySelector('.thumbs-list');
        const thumbButtons = Array.from(slider.querySelectorAll('.thumb-btn'));
        const prevBtn = slider.querySelector('.slider-arrow--prev');
        const nextBtn = slider.querySelector('.slider-arrow--next');
        const mainArea = slider.querySelector('.slider-main');
        let currentIndex = 0;
        const total = productImages.length;

        // Render the current image and status text
        const render = () => {
          const src = productImages[currentIndex] || '';
          if (mainImg) {
            mainImg.src = src;
            mainImg.alt = `${sliderAltText} image ${currentIndex + 1}`;
          }
          thumbButtons.forEach(btn => {
            btn.classList.toggle('is-active', Number(btn.dataset.index) === currentIndex);
          });
          if (liveRegion) {
            liveRegion.textContent = `Image ${currentIndex + 1} of ${total}`;
          }
        };

        // Move to specific index with wraparound
        const show = (nextIndex) => {
          currentIndex = (nextIndex + total) % total;
          render();
        };

        // Arrow buttons
        if (prevBtn) {
          prevBtn.addEventListener('click', () => show(currentIndex - 1));
        }
        if (nextBtn) {
          nextBtn.addEventListener('click', () => show(currentIndex + 1));
        }

        // Thumbnail clicks
        if (thumbList) {
          thumbList.addEventListener('click', (event) => {
            const btn = event.target.closest('.thumb-btn');
            if (!btn) return;
            const idx = Number(btn.dataset.index);
            if (!Number.isNaN(idx)) {
              show(idx);
            }
          });
        }

        // Keyboard support on main area
        if (mainArea) {
          mainArea.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowLeft') {
              event.preventDefault();
              show(currentIndex - 1);
            } else if (event.key === 'ArrowRight') {
              event.preventDefault();
              show(currentIndex + 1);
            }
          });
        }

        render();
      };

      // Initialize slider on load
      initSlider();
    })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
